<script>
(function(exports) {
    'use strict';

    if (!exports.DragNDrop) {
        exports.DragNDrop = {};
    };

    /**
     * closure globals
     */

    var POSITION_ABOVE = 'above';
    var POSITION_BELOW = 'below';
    var POSITION_APPEND_INSIDE = 'append-inside';

    function InsertionPoint(element, position) {
        /**
         * @property {string} position Can be 'above', 'below', 'append-inside'
         */
        position: '';
        /**
         * @property {PolymerElement} element Element to be inserted before or after 
         */
        element: {};

        this.position = position;
        this.element = element;
    };

    var _updateCallBacks = {},
        _ghost = {},
        _currentDragTarget,
        _inDrag = false,
        _globalDropRegistry;

    function generateId(prefix) {
        return prefix + '_' + Math.floor(Math.random() * 100);
    }

    function setEventData(dragEvent, data) {
        dragEvent.dataTransfer.setData('text/json', JSON.stringify(data));
    };

    function getEventData(dragEvent) {
        if (dragEvent.dataTransfer.getData('text/json')) {
            return JSON.parse(dragEvent.dataTransfer.getData('text/json'));
        }
    }

    function registGlobalDrop() {
        document.addEventListener('drop', function(event) {

        })
    }
    /**
     * 
     *
     * @polymerBehavior DragNDrop.Draggable
     *
     */
    exports.DragNDrop.Draggable = {
        properties: {
            dropTargetClass: {
                type: String,
                reflectToAttribute: true,
                notify: false,
                value: 'default'
            },
            draggable: {
                type: Boolean,
                value: true,
                reflectToAttribute: true
            }
        },

        listeners: {
            'dragstart': 'dragRegisterDragStart'
        },
        /**
         * Life cycle
         */
        attached: function() {
            // register id because that is useful when moving stuff around the dom
            if (!this.id) {
                this.id = generateId('draggable_');
            }
        },
        /**
         * delegations
         */
        _getData: function(event) {
            return getEventData(event);
        },

        _setData: function(event, data) {
            setEventData(event, data);
        },

        /**
         * event handlers
         */

        /**
         * registers data needed by drop event handler with the drag event's
         * DataTransfer object
         *
         * @event dragstart
         *
         **/
        dragRegisterDragStart: function(event) {
            _inDrag = true;

            if (!getEventData(event)) {
                var transferData = {};
                transferData.elementId = this.id;
                _currentDragTarget = this.id;
                transferData.dropClass = this.dropTargetClass;
                var thisRect = this.getBoundingClientRect();
                var div = document.createElement('div');
                div.innerHTML = this.innerHTML;
                var ghostElement = document.createElement('drag-n-drop-ghost');
                ghostElement.set('dropTargetClass', transferData.dropClass);
                Polymer.dom(ghostElement).appendChild(div);
                _ghost = {
                    element: ghostElement,
                    rect: {
                        height: thisRect.height,
                        width: thisRect.width
                    },
                    placedAt: null
                };
                this._setEventDataTransferDragItem(event, transferData);
                setEventData(event, transferData);
                // this.hidden = true;
            }
        },

        /**
         * methods meant for @override by using elements
         */

        /**
         * Provides custom data to be attached to the DataTransfer object 
         * of the event 
         * @param {DragEvent} dragstart
         * @param {Object} data Add custom data to the data object 
         * 
         */
        _setEventDataTransferDragItem: function(event, data) {
            /** implement logic for data driven scenarios here **/
        }
    };

    /**
     *
     * @polymerBehavior DragNDrop.DropTarget
     *
     */
    exports.DragNDrop.DropTarget = {

        properties: {
            dropClass: {
                type: String,
                reflectToAttribute: true,
                notify: false,
                value: 'default'
            }
        },

        listeners: {
            'dragstart': '_dropRegisterDragStart',
            'dragover': '_enableDrag',
            'drop': '_handleDropElement'
        },

        /**
         * Life cycle
         */
        attached: function() {
            // register id because that is useful when moving stuff around the dom
            if (!this.id) {
                this.id = 'dropTarget_' + Math.floor(Math.random() * 1000);
            }
        },
        /**
         * delegations
         */
        _getData: function(event) {
            return getEventData(event);
        },

        _setData: function(event, data) {
            setEventData(event, data);
        },

        /**
         * Decides whether the dragged element should be placed above or below the 
         * hovered sibling
         * algorithm:
         * - get height of element
         */
        _decideAboveBelow: function(eventMetadata, targetMetadata) {
            var elementHeight = targetMetadata.rect.height;
            var yPositionInsideElement = eventMetadata.clientY - targetMetadata.rect.top;
            console.log(yPositionInsideElement / targetMetadata.rect.height);
            console.log(Math.round(yPositionInsideElement / targetMetadata.rect.height) < 1);
            if (Math.round(yPositionInsideElement / targetMetadata.rect.height) < 1) {
                return POSITION_ABOVE;
            } else {
                return POSITION_BELOW;
            }
        },
        /**
         * event handlers
         */

        /**
         * @event dragstart
         */
        _dropRegisterDragStart: function(event) {
            var transferData = getEventData(event);
            if (transferData.dropClass === this.dropClass) {
                transferData.sourceContainer = this.id;
                var callback = this._getDropCallBack(event);
                if (typeof(callback) == 'function') {
                    transferData.sourceCallback = this._registerDropCallBack(callback);
                }
                this._addDataDragStartDropTarget(event, transferData);
                setEventData(event, transferData);
                event.stopPropagation();
            }
        },

        /**
         * @event drop
         */
        _handleDropElement: function(event) {
            _inDrag = false;
            var transferData = getEventData(event);
            if (this.dropClass === transferData.dropClass) {
                this._insertDroppedElement(event);
                var callback = transferData.sourceCallback;
                if (typeof(_updateCallBacks[callback]) == 'function') {
                    _updateCallBacks[callback](event);
                    delete _updateCallBacks[callback];
                }
            }
            this._removeGhost();
            event.stopPropagation();
            event.preventDefault();
            _currentDragTarget = null;
        },

        _enableDrag: function(event) {
            event.preventDefault();
            this._showDropTarget(event);
        },

        /**
         * Managing the mouse position relative to the hover target
         */
        _getRelativeMousePosition: function(event) {
            var xPos = event.originalEvent.clientX;
            var yPos = event.originalEvent.clientY;
        },

        _getDropCallBack: function(event) {
            // implement if required
        },


        _registerDropCallBack: function(callback) {
            // register drop call ... useful if the source container is not the 
            // drop container but data still needs to be updated
            _updateCallBacks[this.id] = callback;
            return this.id;
        },

        _removeGhost: function() {
            Polymer.dom(this).removeChild(_ghost.element);
        },
        /**
         * methods meant for @override by using elements
         */

        /**
         * Provides custom data to be attached to the DataTransfer object 
         * of the event 
         * @param {DragEvent} dragstart
         * @param {Object} data Add custom data to the data object 
         * 
         */
        _addDataDragStartDropTarget: function(event, transferData) {
            // append data required for drop handling
        },

        _updateContent: function(event) {
            console.log('i will do something: ' + this.id);
        },

        /**
         * Manage the insertion of a element to be droppend
         * @param {DropEvent} event
         */
        _insertDroppedElement: function(event) {
            var transferData = getEventData(event);
            var insertionPoint = this._getInsertionPoint(event);
            var elementToInsert = document.getElementById(transferData.elementId);
            // this._insertElement(elementToInsert, insertionPoint);
            Polymer.dom(this).insertBefore(elementToInsert, Polymer.dom(this).querySelector('drag-n-drop-ghost'));
        },

        /**
         * Finds the insertion point, be it for the dopped element or the ghost
         * @param {DragEvent} event
         * @returns {InsertionPoint} 
         */
        _getInsertionPoint: function(event) {
            var elementId = _currentDragTarget;
            var insertBeforeElement = this._findEventTargetSibling(event.target);
            if (insertBeforeElement === _ghost.element) {
                return;
            } else if (insertBeforeElement) {
                var eventMetadata = {
                    screenx: event.screenX,
                    screeny: event.screenY,
                    offsetx: event.offsetX,
                    offsety: event.offsetY,
                    x: event.x,
                    y: event.y,
                    clientX: event.clientX,
                    clientY: event.clientY
                };

                var targetMetadata = {
                    left: insertBeforeElement.offsetLeft,
                    top: insertBeforeElement.offsetTop,
                    rect: insertBeforeElement.getBoundingClientRect()
                };

                if (insertBeforeElement.nextSibling === Polymer.dom(document.getElementById(elementId))) {
                    return new InsertionPoint(insertBeforeElement, POSITION_BELOW);
                } else {
                    return new InsertionPoint(insertBeforeElement, this._decideAboveBelow(eventMetadata, targetMetadata));
                }
            } else {
                return new InsertionPoint(this, POSITION_APPEND_INSIDE);
            }
        },


        _getParentPolymerElement: function(element, dropClass) {
            if (Polymer.dom(element).node.host) {
                if (Polymer.dom(element).node.host.dropTargetClass === dropClass || element.nodeName === 'DRAG-N-DROP-GHOST') {
                    if (element.nodeName === 'DRAG-N-DROP-GHOST') {
                        console.log('HOVERED A GHOST');
                    }
                    return Polymer.dom(element).node.host; // got it ...
                } else {
                    return this._getParentPolymerElement(Polymer.dom(element).parentNode, dropClass); // recursion
                }
            } else if (Polymer.dom(element).parentNode === null) {
                return; // exit recursion
            } else {
                return this._getParentPolymerElement(Polymer.dom(element).parentNode, dropClass); // recursion
            }
        },

        _findEventTargetSibling: function(dropTarget) {
            var compareTargetClass = this.dropClass;
            var polymerElement = this._getParentPolymerElement(dropTarget, compareTargetClass);
            return polymerElement;
        },

        _insertElement: function(element, insertionPoint) {
            console.log(insertionPoint.position);
            switch (insertionPoint.position) {
                case POSITION_ABOVE:
                    Polymer.dom(this).insertBefore(element, insertionPoint.element);
                    break;
                case POSITION_BELOW:
                    Polymer.dom(this).insertBefore(element, Polymer.dom(insertionPoint.element).nextSibling);
                    // Polymer.dom(this).insertBefore(Polymer.dom(element).nextSibling, insertionPoint.element);
                    break;
                case POSITION_APPEND_INSIDE:
                    Polymer.dom(insertionPoint.element).appendChild(element);
                    break;
            }
        },

        _showDropTarget: function(event) {
            if (_inDrag === true) {
                // dataTransfer is in protected mode at this stage, so do not try
                // to interact with it
                var transferData = getEventData(event);
                var insertionPoint = this._getInsertionPoint(event);
                if (insertionPoint.element !== _ghost.element) {
                    this._insertElement(_ghost.element, insertionPoint);
                }
                event.preventDefault();
                event.stopPropagation();
            }
        }


    }

})(window)
</script>
<dom-module id="drag-n-drop-ghost">
    <template>
        <style>
        div {
            background-color: #aaa;
            /**/
            opacity: 0.5;
        }
        </style>
        <div>
            <content>
            </content>
        </div>
    </template>
    <script>
    Polymer({
        is: 'drag-n-drop-ghost',
        properties: {},
        behaviors: [DragNDrop.Draggable],

        ready: function() {
            this.id = 'ghost_' + Math.floor(Math.random() * 100);
        },

        listeners: {
            'dragover': '_stopPropagation'
        },

        _stopPropagation: function(event) {
            event.stopPropagation();
            event.preventDefault();
        }


    })
    </script>
</dom-module>
